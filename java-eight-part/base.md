# 一个".java"源文件中是否可以包括多个类（不是内部类）？有什么限制？
可以有多个类，但是只能有一个Public类，并且类名要与文件名一致。
为何？
每个.java文件都是一个编译单元，这个有一单位内的类有单一的公共接口
这个接口中可以包涵众多非Public类

# java中有goto吗？
没有，不能使用，但是是保留字
为何？
goto会降低可维护性和可读性

# &和&&的区别
两者都可以作为逻辑与的运算使用
区别：
&& 具有短路的功能，当前一个表达为false时，不计算后一个表达式
& 具有位运算的功能

# JAVA中如何跳出当前的多重嵌套循环
break即可

# switch语句能否作用在byte上，能否作用在long上，能否作用在String上
这里说一下switch的作用范围：
> 整数表达式或者枚举常量
因为 byte,short,char都可转化为int,因此支持int,byte,string
*但是switch不支持long类型，谨记*

# short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?
这个涉及到类型转化的知识点，以及 += 的逻辑
在Java中默认的数字类型是int,因此将s1提升为int
因此计算s1=s1+1时会将s1+1转化为int
将int赋给s1,向下转化，那么就会报告需要强转的错误

+=编译器对其进行特殊处理，因此可以正常编译

# char型变量中能不能存贮一个中文汉字?为什么?
char变量用来存储unicode编码的字符，而unicode编码字符集中包含了汉字
> 相对的，什么字符集中不包涵汉字呢？
> ascll中只有英语字符和符号
> 什么字符集中包涵汉字呢？
> gb2312 gbk(在gb2312基础上添加了首符号等符号)
> unicode 收录全世界的文字和符号
在java中,char为两个字节16位，因此可以存储一个汉字

# 用最有效率的方法算出2乘以8等于几?
位运算cpu直接支持，效率最高
将一个数左移n位，相当于乘以2的n次方
因此使用2<<3效率最高

# 请设计一个一百亿的计算器
考察几个方面
* 加减法的位运算原理
* 算数运算法发生越界的情况
* 面向对象的设计思想

位运算原理：两个数值的运算结果不能超过计算机中该类型的表示范围
那么怎么计算表示范围呢？
设该存储单位有n位
无符号：0->2n次方-1
有符号：-2的(n-1)次方 -> 2的（n-1次方）-1
如short : -128->127
正数少一位是因为有一位分配给了0

int的范围是20亿左右，这里百亿是超过了，不使用long的情况下
我们设计一个类存储这个很大的整数，并提供加减乘除的功能

设计两个成员变量：
* 可以使用Bool设计符号
* 使用字节数组表示数值的二进制数
* 一个构造方法将字符串转为内部的字节数组
* 提供add ,subtract , multiply ,divide

# 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？
这里引用值得是这个变量对应的类的引用
使用final修饰什么什么不能改变，因此这个引用是不能改变的，也就是所指向的内容不能改变
但是引用的内容改变是没有问题的

# "=="和equals方法究竟有什么区别？
==操作符专门用来比较两个变量的值是否相同
可以比较两个基本类型的数据，或者两个引用变量是否相同

但是如果一个变量指向的数据类型是对象类型的，==比较的是两者是否指向同一个对象
.equals比较两个独立内容的内容是否相同

如字符串的比较就要使用equals

# 静态变量和实例变量的区别？
什么是静态变量？ 使用static修饰的变量
实例变量是什么？ 不使用static修饰的变量

* 实例变量属于某个对象的属性，必须创建了实例才能使用
* 静态变量属于某个类的对象，只要程序加载了类的字节码，不需要创建任何实例即可使用

# 是否可以从一个static方法内部发出对非static方法的调用？
不可以，非static方法属于具体的对象
而static属于类，当static方法被调用的时候，可能还没有任何实例

# Integer与int的区别
int是基本数据类型，默认值为0
Integer是int的封装类，默认为null
int无法表示未赋值的情况，int不适合作为web层的表单数据的类型

Integer提供了多个与整数相关的操作方法：
字符串->整数
最大最小常量

# Math.round(11.5)等于多少? Math.round(-11.5)等于多少?
math的三种取整运算
* ceil 天花板，向上取证
* round 四舍五入，算法为floor(x+0.5)
* floor 向下取整

# 请说出作用域public，private，protected，以及不写时的区别
不写的时候默认friendly
| 作用域     | 当前类 | 同一package | 子孙类 | 其他package |
|:----------|:------|:-----------|:------|:-----------|
| public    | √     | √          | √    | √          |
| protected | √     | √          | √    | ×          |
| friendly  | √     | √          | ×     | ×          |
| private   | √     | ×         | ×     | ×          |

亲密关系的划分，最亲密的肯定是自己，当前类的中所有变量都可访问
接下来是子孙类，也就是自己的子类
接下来是和当前类没有关系的，同一个包中的类
最后是其他包中的类，那就更没关系了

piblic和private很好辨认
接下来是protect:首先是作为子类可以访问受保护的量，同时同一包中可以访问
friendly 友元，只有自己和同一包中的类可以访问

# Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型
overload是重载
override是重写
* 重载表示一个类中有多个名称相同的方法，但是参数列表可以不同
* 重写表示子类的方法的名称和参数完全相同，将父类中这个表面完全相同的方法覆盖掉

override的参数是一样的，那么当然不可以改变返回类型
overload虽然参数不一致，但是我们想要得出的结果是一致的，因此不能更改返回值类型

关于覆盖，有一些点需要注意：
首先是覆盖的条件：
* 覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果
* 覆盖的方法的返回值必须和被覆盖的方法的返回一致；
* 覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类（因为覆盖不能引出更大的问题，子问题应该是父问题的具体解决）
* 被覆盖的方法不能为Private，不然只是重新定义了一个新方法

关于重载，有一些地方需要注意：
* 不能通过访问权限、返回类型、抛出的异常进行重载
* 方法的异常类型和数目不会对重载造成影响
* 对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果

# 构造器Constructor是否可被override?
不可以，constructor不可以被继承，当然也不可以被重载

# 接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承具体类(concrete class)? 抽象类中是否可以有静态的main方法？
先进行基本知识的梳理：
*接口*
* 接口：是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为
* 并不能直接去实例化一个接口，因为接口中的方法都是抽象的
* 但是，我们可以使用接口类型的引用指向一个实现了该接口的对象
* 接口也可以继承，并且可以多继承
* 接口中所有的方法都是抽象的和public的，所有的属性都是public,static,final的
* 一个类如果要实现某个接口的话，那么它必须要实现这个接口中的所有方法。

*抽象类*
* 如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。
* 抽象类可以没有抽象方法，但是如果有抽象方法的类，必须被申明为抽象类
* 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。具有抽象方法的类一定为抽象类。
* 尽管不能实例化一个抽象类，但是可以实例化一个继承了抽象类的子类，然后将抽象类的引用指向子类的对象。
* 抽象类可实现接口，并且可以不实现接口中的方法，但是继承抽象类的实体类必须实现接口中的方法。

1.接口是否可继承接口：可以继承多个接口
2.抽象类是否可实现接口：可以，并且可以不实现接口中的方法，但是继承抽象类的实体类必须实现接口中的方法。
3.抽象类是否可继承具体类(concrete class):可以，抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法
4.抽象类中是否可以有静态的main方法：可以，抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法

# 写clone()方法时，通常都有一行代码，是什么
clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己的成员

-----

# 面向对象的特征
目的是将现实生活中的业务对象映射到计算机系统中
* 封装：把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中
* 继承：继承是子类自动共享父类数据和方法的机制
* 抽象：抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面
* 多态：程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定
> 即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

# 实现多态的机制
父类或接口定义的引用变量可以指向子类或具体实现类的实例对象

# abstract class和interface有什么区别?
abstract class和class有两个区别
* 抽象类不能创建对象
* 抽象类中可以有抽象方法，但类中不可以有抽象方法

interface是接口
* interface中所有方法都是抽象的，可以视为是抽象类的一种特例
* interface中所有的方法都是 public abstract
* interface中所有变量都默认使用 public static final
> 为什么所有变量都是pubic static final呢？
> 首先Public很好理解，接口得公开才能具体实现
> static表示该变量为静态，实现这个接口的类，可以直接使用这个变量。如果是非静态变量，那么接口的多个实现类可能出现变量名重名的现象。
> final表示该变量不能更改，在具体的类实现时不能更改。

1. 抽象类中可以有构造方法，接口中不能有构造方法，构造方法是私有的哇
2. 抽象类中可以有普通成员变量，而接口中不可能
3. 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的
4. 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的
5. 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的,但接口中定义的变量只能是public static final类型
6. 一个类可以实现多个接口，但只能继承一个抽象类。
7. 接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用


# abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?
* static表示静态，让类方法在未被实例化时可以被调用，但是抽象方法需要子类进行具体实现，所以肯定是不行的
* native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用
* 不行，synchronized应该是作用在一个具体的方法上才有意义

# 什么是内部类？Static Nested Class 和 Inner Class的不同
内部类就是在一个类的内部定义的类，内部类中不能定义静态成员
> 把“全局变量”放在内部类中就是毫无意义的事情
内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中

* 关于创建内部类
* 创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象
* 关于方法内定义的内部类
* 内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样
> 和局部类是相似的
* 关于方法外定义的内部类
* 内部类前面可以加上static关键字，从而成为Static Nested Class
* 只有静态内部类才能够定义静态的成员变量与成员方法
* 静态内部类无法访问外部成员的普通变量

### 总而言之：可以访问外部类的成员变量，不能定义静态成员，这是大的特点
两种模式，方法内定义（相当于局部变量），方法外定义（可以加static关键字）

# 内部类可以引用它的包含类的成员吗？有没有什么限制
可以的老弟，没问题：一般的非静态内部类，可以随意的访问外部类中的成员变量与成员方法
但是如果是静态内部类，那么只能引用外部类中的静态的成员（变量或方法），而不能够访问非静态的变量
> 啊为什么呢？因为静态内部类在外部类定义的时候就已经初始化好了，但是外部类的非静态成员需要实例才能初始化
> 因此若是没有实例对象，那么静态内部类是无访问未初始化的数据的

# Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?
可以啊，匿名类也是类啊

# super.getClass()方法调用
super.getClass().getName()得到的是当前类的名字
getClass()方法返回的是当前运行的类
这是因为getClass()在Object类中定义成了final，子类不能覆盖该方法

如果想得到父类的名称，应该用如下代码：getClass().getSuperClass().getName();

# String是最基本的数据类型吗
不是，基本数据类型包括byte、int、char、long、float、double、boolean和short。
java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类

# String s = "Hello";s = s + " world!";这两行代码执行后，原始的String对象中的内容到底变了没有？
没有啊，string使用final修饰，不可以修改其值，也不可以继承

但是产生了一个新的string
* s原先指向一个String对象，内容是 "Hello"
* 然后我们对s进行了+操作，这时，s不指向原来那个对象了。而指向了另一个 String对象，内容为"Hello world!"
* 原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。

应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。

不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题

# 是否可以继承String类?
不可以，final

# String s = new String("xyz");创建了几个String Object? 二者之间有什么区别？
2个或者1个
